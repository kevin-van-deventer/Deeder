{"ast":null,"code":"var adapters = {\n  logger: typeof console !== \"undefined\" ? console : undefined,\n  WebSocket: typeof WebSocket !== \"undefined\" ? WebSocket : undefined\n};\nvar logger = {\n  log(...messages) {\n    if (this.enabled) {\n      messages.push(Date.now());\n      adapters.logger.log(\"[ActionCable]\", ...messages);\n    }\n  }\n};\nconst now = () => new Date().getTime();\nconst secondsSince = time => (now() - time) / 1e3;\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now();\n      delete this.stoppedAt;\n      this.startPolling();\n      addEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);\n    }\n  }\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now();\n      this.stopPolling();\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor stopped\");\n    }\n  }\n  isRunning() {\n    return this.startedAt && !this.stoppedAt;\n  }\n  recordMessage() {\n    this.pingedAt = now();\n  }\n  recordConnect() {\n    this.reconnectAttempts = 0;\n    delete this.disconnectedAt;\n    logger.log(\"ConnectionMonitor recorded connect\");\n  }\n  recordDisconnect() {\n    this.disconnectedAt = now();\n    logger.log(\"ConnectionMonitor recorded disconnect\");\n  }\n  startPolling() {\n    this.stopPolling();\n    this.poll();\n  }\n  stopPolling() {\n    clearTimeout(this.pollTimeout);\n  }\n  poll() {\n    this.pollTimeout = setTimeout(() => {\n      this.reconnectIfStale();\n      this.poll();\n    }, this.getPollInterval());\n  }\n  getPollInterval() {\n    const {\n      staleThreshold: staleThreshold,\n      reconnectionBackoffRate: reconnectionBackoffRate\n    } = this.constructor;\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));\n    const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;\n    const jitter = jitterMax * Math.random();\n    return staleThreshold * 1e3 * backoff * (1 + jitter);\n  }\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);\n      this.reconnectAttempts++;\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);\n      } else {\n        logger.log(\"ConnectionMonitor reopening\");\n        this.connection.reopen();\n      }\n    }\n  }\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt;\n  }\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;\n  }\n  disconnectedRecently() {\n    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n  }\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout(() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);\n          this.connection.reopen();\n        }\n      }, 200);\n    }\n  }\n}\nConnectionMonitor.staleThreshold = 6;\nConnectionMonitor.reconnectionBackoffRate = .15;\nvar INTERNAL = {\n  message_types: {\n    welcome: \"welcome\",\n    disconnect: \"disconnect\",\n    ping: \"ping\",\n    confirmation: \"confirm_subscription\",\n    rejection: \"reject_subscription\"\n  },\n  disconnect_reasons: {\n    unauthorized: \"unauthorized\",\n    invalid_request: \"invalid_request\",\n    server_restart: \"server_restart\",\n    remote: \"remote\"\n  },\n  default_mount_path: \"/cable\",\n  protocols: [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n};\nconst {\n  message_types: message_types,\n  protocols: protocols\n} = INTERNAL;\nconst supportedProtocols = protocols.slice(0, protocols.length - 1);\nconst indexOf = [].indexOf;\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data));\n      return true;\n    } else {\n      return false;\n    }\n  }\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);\n      return false;\n    } else {\n      const socketProtocols = [...protocols, ...(this.consumer.subprotocols || [])];\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);\n      if (this.webSocket) {\n        this.uninstallEventHandlers();\n      }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, socketProtocols);\n      this.installEventHandlers();\n      this.monitor.start();\n      return true;\n    }\n  }\n  close({\n    allowReconnect: allowReconnect\n  } = {\n    allowReconnect: true\n  }) {\n    if (!allowReconnect) {\n      this.monitor.stop();\n    }\n    if (this.isOpen()) {\n      return this.webSocket.close();\n    }\n  }\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);\n    if (this.isActive()) {\n      try {\n        return this.close();\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error);\n      } finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);\n        setTimeout(this.open, this.constructor.reopenDelay);\n      }\n    } else {\n      return this.open();\n    }\n  }\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol;\n    }\n  }\n  isOpen() {\n    return this.isState(\"open\");\n  }\n  isActive() {\n    return this.isState(\"open\", \"connecting\");\n  }\n  triedToReconnect() {\n    return this.monitor.reconnectAttempts > 0;\n  }\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n  }\n  isState(...states) {\n    return indexOf.call(states, this.getState()) >= 0;\n  }\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase();\n        }\n      }\n    }\n    return null;\n  }\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this);\n      this.webSocket[`on${eventName}`] = handler;\n    }\n  }\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function () {};\n    }\n  }\n}\nConnection.reopenDelay = 500;\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n    const {\n      identifier: identifier,\n      message: message,\n      reason: reason,\n      reconnect: reconnect,\n      type: type\n    } = JSON.parse(event.data);\n    this.monitor.recordMessage();\n    switch (type) {\n      case message_types.welcome:\n        if (this.triedToReconnect()) {\n          this.reconnectAttempted = true;\n        }\n        this.monitor.recordConnect();\n        return this.subscriptions.reload();\n      case message_types.disconnect:\n        logger.log(`Disconnecting. Reason: ${reason}`);\n        return this.close({\n          allowReconnect: reconnect\n        });\n      case message_types.ping:\n        return null;\n      case message_types.confirmation:\n        this.subscriptions.confirmSubscription(identifier);\n        if (this.reconnectAttempted) {\n          this.reconnectAttempted = false;\n          return this.subscriptions.notify(identifier, \"connected\", {\n            reconnected: true\n          });\n        } else {\n          return this.subscriptions.notify(identifier, \"connected\", {\n            reconnected: false\n          });\n        }\n      case message_types.rejection:\n        return this.subscriptions.reject(identifier);\n      default:\n        return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);\n    this.disconnected = false;\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n  close(event) {\n    logger.log(\"WebSocket onclose event\");\n    if (this.disconnected) {\n      return;\n    }\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n  error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n};\nconst extend = function (object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key];\n      object[key] = value;\n    }\n  }\n  return object;\n};\nclass Subscription {\n  constructor(consumer, params = {}, mixin) {\n    this.consumer = consumer;\n    this.identifier = JSON.stringify(params);\n    extend(this, mixin);\n  }\n  perform(action, data = {}) {\n    data.action = action;\n    return this.send(data);\n  }\n  send(data) {\n    return this.consumer.send({\n      command: \"message\",\n      identifier: this.identifier,\n      data: JSON.stringify(data)\n    });\n  }\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this);\n  }\n}\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions;\n    this.pendingSubscriptions = [];\n  }\n  guarantee(subscription) {\n    if (this.pendingSubscriptions.indexOf(subscription) == -1) {\n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);\n      this.pendingSubscriptions.push(subscription);\n    } else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);\n    }\n    this.startGuaranteeing();\n  }\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);\n    this.pendingSubscriptions = this.pendingSubscriptions.filter(s => s !== subscription);\n  }\n  startGuaranteeing() {\n    this.stopGuaranteeing();\n    this.retrySubscribing();\n  }\n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout);\n  }\n  retrySubscribing() {\n    this.retryTimeout = setTimeout(() => {\n      if (this.subscriptions && typeof this.subscriptions.subscribe === \"function\") {\n        this.pendingSubscriptions.map(subscription => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);\n          this.subscriptions.subscribe(subscription);\n        });\n      }\n    }, 500);\n  }\n}\nclass Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer;\n    this.guarantor = new SubscriptionGuarantor(this);\n    this.subscriptions = [];\n  }\n  create(channelName, mixin) {\n    const channel = channelName;\n    const params = typeof channel === \"object\" ? channel : {\n      channel: channel\n    };\n    const subscription = new Subscription(this.consumer, params, mixin);\n    return this.add(subscription);\n  }\n  add(subscription) {\n    this.subscriptions.push(subscription);\n    this.consumer.ensureActiveConnection();\n    this.notify(subscription, \"initialized\");\n    this.subscribe(subscription);\n    return subscription;\n  }\n  remove(subscription) {\n    this.forget(subscription);\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\");\n    }\n    return subscription;\n  }\n  reject(identifier) {\n    return this.findAll(identifier).map(subscription => {\n      this.forget(subscription);\n      this.notify(subscription, \"rejected\");\n      return subscription;\n    });\n  }\n  forget(subscription) {\n    this.guarantor.forget(subscription);\n    this.subscriptions = this.subscriptions.filter(s => s !== subscription);\n    return subscription;\n  }\n  findAll(identifier) {\n    return this.subscriptions.filter(s => s.identifier === identifier);\n  }\n  reload() {\n    return this.subscriptions.map(subscription => this.subscribe(subscription));\n  }\n  notifyAll(callbackName, ...args) {\n    return this.subscriptions.map(subscription => this.notify(subscription, callbackName, ...args));\n  }\n  notify(subscription, callbackName, ...args) {\n    let subscriptions;\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription);\n    } else {\n      subscriptions = [subscription];\n    }\n    return subscriptions.map(subscription => typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined);\n  }\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription);\n    }\n  }\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`);\n    this.findAll(identifier).map(subscription => this.guarantor.forget(subscription));\n  }\n  sendCommand(subscription, command) {\n    const {\n      identifier: identifier\n    } = subscription;\n    return this.consumer.send({\n      command: command,\n      identifier: identifier\n    });\n  }\n}\nclass Consumer {\n  constructor(url) {\n    this._url = url;\n    this.subscriptions = new Subscriptions(this);\n    this.connection = new Connection(this);\n    this.subprotocols = [];\n  }\n  get url() {\n    return createWebSocketURL(this._url);\n  }\n  send(data) {\n    return this.connection.send(data);\n  }\n  connect() {\n    return this.connection.open();\n  }\n  disconnect() {\n    return this.connection.close({\n      allowReconnect: false\n    });\n  }\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open();\n    }\n  }\n  addSubProtocol(subprotocol) {\n    this.subprotocols = [...this.subprotocols, subprotocol];\n  }\n}\nfunction createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url();\n  }\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.href = a.href;\n    a.protocol = a.protocol.replace(\"http\", \"ws\");\n    return a.href;\n  } else {\n    return url;\n  }\n}\nfunction createConsumer(url = getConfig(\"url\") || INTERNAL.default_mount_path) {\n  return new Consumer(url);\n}\nfunction getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}\nexport { Connection, ConnectionMonitor, Consumer, INTERNAL, Subscription, SubscriptionGuarantor, Subscriptions, adapters, createConsumer, createWebSocketURL, getConfig, logger };","map":{"version":3,"names":["adapters","logger","console","undefined","WebSocket","log","messages","enabled","push","Date","now","getTime","secondsSince","time","ConnectionMonitor","constructor","connection","visibilityDidChange","bind","reconnectAttempts","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","staleThreshold","stop","stopPolling","removeEventListener","recordMessage","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","getPollInterval","reconnectionBackoffRate","backoff","Math","pow","min","jitterMax","jitter","random","connectionIsStale","refreshedAt","disconnectedRecently","reopen","document","visibilityState","isOpen","INTERNAL","message_types","welcome","disconnect","ping","confirmation","rejection","disconnect_reasons","unauthorized","invalid_request","server_restart","remote","default_mount_path","protocols","supportedProtocols","slice","length","indexOf","Connection","consumer","open","subscriptions","monitor","disconnected","send","data","webSocket","JSON","stringify","isActive","getState","socketProtocols","subprotocols","uninstallEventHandlers","url","installEventHandlers","close","allowReconnect","error","reopenDelay","getProtocol","protocol","isState","triedToReconnect","isProtocolSupported","call","states","state","readyState","toLowerCase","eventName","events","handler","prototype","message","event","identifier","reason","reconnect","type","parse","reconnectAttempted","reload","confirmSubscription","notify","reconnected","reject","notifyAll","willAttemptReconnect","extend","object","properties","key","value","Subscription","params","mixin","perform","action","command","unsubscribe","remove","SubscriptionGuarantor","pendingSubscriptions","guarantee","subscription","startGuaranteeing","forget","filter","s","stopGuaranteeing","retrySubscribing","retryTimeout","subscribe","map","Subscriptions","guarantor","create","channelName","channel","add","ensureActiveConnection","findAll","sendCommand","callbackName","args","Consumer","_url","createWebSocketURL","connect","addSubProtocol","subprotocol","test","a","createElement","href","replace","createConsumer","getConfig","name","element","head","querySelector","getAttribute"],"sources":["/home/kevin/deeder/frontend/node_modules/@rails/actioncable/app/assets/javascripts/actioncable.esm.js"],"sourcesContent":["var adapters = {\n  logger: typeof console !== \"undefined\" ? console : undefined,\n  WebSocket: typeof WebSocket !== \"undefined\" ? WebSocket : undefined\n};\n\nvar logger = {\n  log(...messages) {\n    if (this.enabled) {\n      messages.push(Date.now());\n      adapters.logger.log(\"[ActionCable]\", ...messages);\n    }\n  }\n};\n\nconst now = () => (new Date).getTime();\n\nconst secondsSince = time => (now() - time) / 1e3;\n\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now();\n      delete this.stoppedAt;\n      this.startPolling();\n      addEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);\n    }\n  }\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now();\n      this.stopPolling();\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor stopped\");\n    }\n  }\n  isRunning() {\n    return this.startedAt && !this.stoppedAt;\n  }\n  recordMessage() {\n    this.pingedAt = now();\n  }\n  recordConnect() {\n    this.reconnectAttempts = 0;\n    delete this.disconnectedAt;\n    logger.log(\"ConnectionMonitor recorded connect\");\n  }\n  recordDisconnect() {\n    this.disconnectedAt = now();\n    logger.log(\"ConnectionMonitor recorded disconnect\");\n  }\n  startPolling() {\n    this.stopPolling();\n    this.poll();\n  }\n  stopPolling() {\n    clearTimeout(this.pollTimeout);\n  }\n  poll() {\n    this.pollTimeout = setTimeout((() => {\n      this.reconnectIfStale();\n      this.poll();\n    }), this.getPollInterval());\n  }\n  getPollInterval() {\n    const {staleThreshold: staleThreshold, reconnectionBackoffRate: reconnectionBackoffRate} = this.constructor;\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));\n    const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;\n    const jitter = jitterMax * Math.random();\n    return staleThreshold * 1e3 * backoff * (1 + jitter);\n  }\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);\n      this.reconnectAttempts++;\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);\n      } else {\n        logger.log(\"ConnectionMonitor reopening\");\n        this.connection.reopen();\n      }\n    }\n  }\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt;\n  }\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;\n  }\n  disconnectedRecently() {\n    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n  }\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout((() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);\n          this.connection.reopen();\n        }\n      }), 200);\n    }\n  }\n}\n\nConnectionMonitor.staleThreshold = 6;\n\nConnectionMonitor.reconnectionBackoffRate = .15;\n\nvar INTERNAL = {\n  message_types: {\n    welcome: \"welcome\",\n    disconnect: \"disconnect\",\n    ping: \"ping\",\n    confirmation: \"confirm_subscription\",\n    rejection: \"reject_subscription\"\n  },\n  disconnect_reasons: {\n    unauthorized: \"unauthorized\",\n    invalid_request: \"invalid_request\",\n    server_restart: \"server_restart\",\n    remote: \"remote\"\n  },\n  default_mount_path: \"/cable\",\n  protocols: [ \"actioncable-v1-json\", \"actioncable-unsupported\" ]\n};\n\nconst {message_types: message_types, protocols: protocols} = INTERNAL;\n\nconst supportedProtocols = protocols.slice(0, protocols.length - 1);\n\nconst indexOf = [].indexOf;\n\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data));\n      return true;\n    } else {\n      return false;\n    }\n  }\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);\n      return false;\n    } else {\n      const socketProtocols = [ ...protocols, ...this.consumer.subprotocols || [] ];\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);\n      if (this.webSocket) {\n        this.uninstallEventHandlers();\n      }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, socketProtocols);\n      this.installEventHandlers();\n      this.monitor.start();\n      return true;\n    }\n  }\n  close({allowReconnect: allowReconnect} = {\n    allowReconnect: true\n  }) {\n    if (!allowReconnect) {\n      this.monitor.stop();\n    }\n    if (this.isOpen()) {\n      return this.webSocket.close();\n    }\n  }\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);\n    if (this.isActive()) {\n      try {\n        return this.close();\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error);\n      } finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);\n        setTimeout(this.open, this.constructor.reopenDelay);\n      }\n    } else {\n      return this.open();\n    }\n  }\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol;\n    }\n  }\n  isOpen() {\n    return this.isState(\"open\");\n  }\n  isActive() {\n    return this.isState(\"open\", \"connecting\");\n  }\n  triedToReconnect() {\n    return this.monitor.reconnectAttempts > 0;\n  }\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n  }\n  isState(...states) {\n    return indexOf.call(states, this.getState()) >= 0;\n  }\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase();\n        }\n      }\n    }\n    return null;\n  }\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this);\n      this.webSocket[`on${eventName}`] = handler;\n    }\n  }\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function() {};\n    }\n  }\n}\n\nConnection.reopenDelay = 500;\n\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n    const {identifier: identifier, message: message, reason: reason, reconnect: reconnect, type: type} = JSON.parse(event.data);\n    this.monitor.recordMessage();\n    switch (type) {\n     case message_types.welcome:\n      if (this.triedToReconnect()) {\n        this.reconnectAttempted = true;\n      }\n      this.monitor.recordConnect();\n      return this.subscriptions.reload();\n\n     case message_types.disconnect:\n      logger.log(`Disconnecting. Reason: ${reason}`);\n      return this.close({\n        allowReconnect: reconnect\n      });\n\n     case message_types.ping:\n      return null;\n\n     case message_types.confirmation:\n      this.subscriptions.confirmSubscription(identifier);\n      if (this.reconnectAttempted) {\n        this.reconnectAttempted = false;\n        return this.subscriptions.notify(identifier, \"connected\", {\n          reconnected: true\n        });\n      } else {\n        return this.subscriptions.notify(identifier, \"connected\", {\n          reconnected: false\n        });\n      }\n\n     case message_types.rejection:\n      return this.subscriptions.reject(identifier);\n\n     default:\n      return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);\n    this.disconnected = false;\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n  close(event) {\n    logger.log(\"WebSocket onclose event\");\n    if (this.disconnected) {\n      return;\n    }\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n  error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n};\n\nconst extend = function(object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key];\n      object[key] = value;\n    }\n  }\n  return object;\n};\n\nclass Subscription {\n  constructor(consumer, params = {}, mixin) {\n    this.consumer = consumer;\n    this.identifier = JSON.stringify(params);\n    extend(this, mixin);\n  }\n  perform(action, data = {}) {\n    data.action = action;\n    return this.send(data);\n  }\n  send(data) {\n    return this.consumer.send({\n      command: \"message\",\n      identifier: this.identifier,\n      data: JSON.stringify(data)\n    });\n  }\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this);\n  }\n}\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions;\n    this.pendingSubscriptions = [];\n  }\n  guarantee(subscription) {\n    if (this.pendingSubscriptions.indexOf(subscription) == -1) {\n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);\n      this.pendingSubscriptions.push(subscription);\n    } else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);\n    }\n    this.startGuaranteeing();\n  }\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);\n    this.pendingSubscriptions = this.pendingSubscriptions.filter((s => s !== subscription));\n  }\n  startGuaranteeing() {\n    this.stopGuaranteeing();\n    this.retrySubscribing();\n  }\n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout);\n  }\n  retrySubscribing() {\n    this.retryTimeout = setTimeout((() => {\n      if (this.subscriptions && typeof this.subscriptions.subscribe === \"function\") {\n        this.pendingSubscriptions.map((subscription => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);\n          this.subscriptions.subscribe(subscription);\n        }));\n      }\n    }), 500);\n  }\n}\n\nclass Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer;\n    this.guarantor = new SubscriptionGuarantor(this);\n    this.subscriptions = [];\n  }\n  create(channelName, mixin) {\n    const channel = channelName;\n    const params = typeof channel === \"object\" ? channel : {\n      channel: channel\n    };\n    const subscription = new Subscription(this.consumer, params, mixin);\n    return this.add(subscription);\n  }\n  add(subscription) {\n    this.subscriptions.push(subscription);\n    this.consumer.ensureActiveConnection();\n    this.notify(subscription, \"initialized\");\n    this.subscribe(subscription);\n    return subscription;\n  }\n  remove(subscription) {\n    this.forget(subscription);\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\");\n    }\n    return subscription;\n  }\n  reject(identifier) {\n    return this.findAll(identifier).map((subscription => {\n      this.forget(subscription);\n      this.notify(subscription, \"rejected\");\n      return subscription;\n    }));\n  }\n  forget(subscription) {\n    this.guarantor.forget(subscription);\n    this.subscriptions = this.subscriptions.filter((s => s !== subscription));\n    return subscription;\n  }\n  findAll(identifier) {\n    return this.subscriptions.filter((s => s.identifier === identifier));\n  }\n  reload() {\n    return this.subscriptions.map((subscription => this.subscribe(subscription)));\n  }\n  notifyAll(callbackName, ...args) {\n    return this.subscriptions.map((subscription => this.notify(subscription, callbackName, ...args)));\n  }\n  notify(subscription, callbackName, ...args) {\n    let subscriptions;\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription);\n    } else {\n      subscriptions = [ subscription ];\n    }\n    return subscriptions.map((subscription => typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined));\n  }\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription);\n    }\n  }\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`);\n    this.findAll(identifier).map((subscription => this.guarantor.forget(subscription)));\n  }\n  sendCommand(subscription, command) {\n    const {identifier: identifier} = subscription;\n    return this.consumer.send({\n      command: command,\n      identifier: identifier\n    });\n  }\n}\n\nclass Consumer {\n  constructor(url) {\n    this._url = url;\n    this.subscriptions = new Subscriptions(this);\n    this.connection = new Connection(this);\n    this.subprotocols = [];\n  }\n  get url() {\n    return createWebSocketURL(this._url);\n  }\n  send(data) {\n    return this.connection.send(data);\n  }\n  connect() {\n    return this.connection.open();\n  }\n  disconnect() {\n    return this.connection.close({\n      allowReconnect: false\n    });\n  }\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open();\n    }\n  }\n  addSubProtocol(subprotocol) {\n    this.subprotocols = [ ...this.subprotocols, subprotocol ];\n  }\n}\n\nfunction createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url();\n  }\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.href = a.href;\n    a.protocol = a.protocol.replace(\"http\", \"ws\");\n    return a.href;\n  } else {\n    return url;\n  }\n}\n\nfunction createConsumer(url = getConfig(\"url\") || INTERNAL.default_mount_path) {\n  return new Consumer(url);\n}\n\nfunction getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}\n\nexport { Connection, ConnectionMonitor, Consumer, INTERNAL, Subscription, SubscriptionGuarantor, Subscriptions, adapters, createConsumer, createWebSocketURL, getConfig, logger };\n"],"mappings":"AAAA,IAAIA,QAAQ,GAAG;EACbC,MAAM,EAAE,OAAOC,OAAO,KAAK,WAAW,GAAGA,OAAO,GAAGC,SAAS;EAC5DC,SAAS,EAAE,OAAOA,SAAS,KAAK,WAAW,GAAGA,SAAS,GAAGD;AAC5D,CAAC;AAED,IAAIF,MAAM,GAAG;EACXI,GAAGA,CAAC,GAAGC,QAAQ,EAAE;IACf,IAAI,IAAI,CAACC,OAAO,EAAE;MAChBD,QAAQ,CAACE,IAAI,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAC;MACzBV,QAAQ,CAACC,MAAM,CAACI,GAAG,CAAC,eAAe,EAAE,GAAGC,QAAQ,CAAC;IACnD;EACF;AACF,CAAC;AAED,MAAMI,GAAG,GAAGA,CAAA,KAAO,IAAID,IAAI,CAAD,CAAC,CAAEE,OAAO,CAAC,CAAC;AAEtC,MAAMC,YAAY,GAAGC,IAAI,IAAI,CAACH,GAAG,CAAC,CAAC,GAAGG,IAAI,IAAI,GAAG;AAEjD,MAAMC,iBAAiB,CAAC;EACtBC,WAAWA,CAACC,UAAU,EAAE;IACtB,IAAI,CAACC,mBAAmB,GAAG,IAAI,CAACA,mBAAmB,CAACC,IAAI,CAAC,IAAI,CAAC;IAC9D,IAAI,CAACF,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACG,iBAAiB,GAAG,CAAC;EAC5B;EACAC,KAAKA,CAAA,EAAG;IACN,IAAI,CAAC,IAAI,CAACC,SAAS,CAAC,CAAC,EAAE;MACrB,IAAI,CAACC,SAAS,GAAGZ,GAAG,CAAC,CAAC;MACtB,OAAO,IAAI,CAACa,SAAS;MACrB,IAAI,CAACC,YAAY,CAAC,CAAC;MACnBC,gBAAgB,CAAC,kBAAkB,EAAE,IAAI,CAACR,mBAAmB,CAAC;MAC9DhB,MAAM,CAACI,GAAG,CAAC,gDAAgD,IAAI,CAACU,WAAW,CAACW,cAAc,IAAI,CAAC;IACjG;EACF;EACAC,IAAIA,CAAA,EAAG;IACL,IAAI,IAAI,CAACN,SAAS,CAAC,CAAC,EAAE;MACpB,IAAI,CAACE,SAAS,GAAGb,GAAG,CAAC,CAAC;MACtB,IAAI,CAACkB,WAAW,CAAC,CAAC;MAClBC,mBAAmB,CAAC,kBAAkB,EAAE,IAAI,CAACZ,mBAAmB,CAAC;MACjEhB,MAAM,CAACI,GAAG,CAAC,2BAA2B,CAAC;IACzC;EACF;EACAgB,SAASA,CAAA,EAAG;IACV,OAAO,IAAI,CAACC,SAAS,IAAI,CAAC,IAAI,CAACC,SAAS;EAC1C;EACAO,aAAaA,CAAA,EAAG;IACd,IAAI,CAACC,QAAQ,GAAGrB,GAAG,CAAC,CAAC;EACvB;EACAsB,aAAaA,CAAA,EAAG;IACd,IAAI,CAACb,iBAAiB,GAAG,CAAC;IAC1B,OAAO,IAAI,CAACc,cAAc;IAC1BhC,MAAM,CAACI,GAAG,CAAC,oCAAoC,CAAC;EAClD;EACA6B,gBAAgBA,CAAA,EAAG;IACjB,IAAI,CAACD,cAAc,GAAGvB,GAAG,CAAC,CAAC;IAC3BT,MAAM,CAACI,GAAG,CAAC,uCAAuC,CAAC;EACrD;EACAmB,YAAYA,CAAA,EAAG;IACb,IAAI,CAACI,WAAW,CAAC,CAAC;IAClB,IAAI,CAACO,IAAI,CAAC,CAAC;EACb;EACAP,WAAWA,CAAA,EAAG;IACZQ,YAAY,CAAC,IAAI,CAACC,WAAW,CAAC;EAChC;EACAF,IAAIA,CAAA,EAAG;IACL,IAAI,CAACE,WAAW,GAAGC,UAAU,CAAE,MAAM;MACnC,IAAI,CAACC,gBAAgB,CAAC,CAAC;MACvB,IAAI,CAACJ,IAAI,CAAC,CAAC;IACb,CAAC,EAAG,IAAI,CAACK,eAAe,CAAC,CAAC,CAAC;EAC7B;EACAA,eAAeA,CAAA,EAAG;IAChB,MAAM;MAACd,cAAc,EAAEA,cAAc;MAAEe,uBAAuB,EAAEA;IAAuB,CAAC,GAAG,IAAI,CAAC1B,WAAW;IAC3G,MAAM2B,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGH,uBAAuB,EAAEE,IAAI,CAACE,GAAG,CAAC,IAAI,CAAC1B,iBAAiB,EAAE,EAAE,CAAC,CAAC;IAC3F,MAAM2B,SAAS,GAAG,IAAI,CAAC3B,iBAAiB,KAAK,CAAC,GAAG,CAAC,GAAGsB,uBAAuB;IAC5E,MAAMM,MAAM,GAAGD,SAAS,GAAGH,IAAI,CAACK,MAAM,CAAC,CAAC;IACxC,OAAOtB,cAAc,GAAG,GAAG,GAAGgB,OAAO,IAAI,CAAC,GAAGK,MAAM,CAAC;EACtD;EACAR,gBAAgBA,CAAA,EAAG;IACjB,IAAI,IAAI,CAACU,iBAAiB,CAAC,CAAC,EAAE;MAC5BhD,MAAM,CAACI,GAAG,CAAC,oEAAoE,IAAI,CAACc,iBAAiB,kBAAkBP,YAAY,CAAC,IAAI,CAACsC,WAAW,CAAC,yBAAyB,IAAI,CAACnC,WAAW,CAACW,cAAc,IAAI,CAAC;MAClN,IAAI,CAACP,iBAAiB,EAAE;MACxB,IAAI,IAAI,CAACgC,oBAAoB,CAAC,CAAC,EAAE;QAC/BlD,MAAM,CAACI,GAAG,CAAC,+EAA+EO,YAAY,CAAC,IAAI,CAACqB,cAAc,CAAC,IAAI,CAAC;MAClI,CAAC,MAAM;QACLhC,MAAM,CAACI,GAAG,CAAC,6BAA6B,CAAC;QACzC,IAAI,CAACW,UAAU,CAACoC,MAAM,CAAC,CAAC;MAC1B;IACF;EACF;EACA,IAAIF,WAAWA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACnB,QAAQ,GAAG,IAAI,CAACA,QAAQ,GAAG,IAAI,CAACT,SAAS;EACvD;EACA2B,iBAAiBA,CAAA,EAAG;IAClB,OAAOrC,YAAY,CAAC,IAAI,CAACsC,WAAW,CAAC,GAAG,IAAI,CAACnC,WAAW,CAACW,cAAc;EACzE;EACAyB,oBAAoBA,CAAA,EAAG;IACrB,OAAO,IAAI,CAAClB,cAAc,IAAIrB,YAAY,CAAC,IAAI,CAACqB,cAAc,CAAC,GAAG,IAAI,CAAClB,WAAW,CAACW,cAAc;EACnG;EACAT,mBAAmBA,CAAA,EAAG;IACpB,IAAIoC,QAAQ,CAACC,eAAe,KAAK,SAAS,EAAE;MAC1ChB,UAAU,CAAE,MAAM;QAChB,IAAI,IAAI,CAACW,iBAAiB,CAAC,CAAC,IAAI,CAAC,IAAI,CAACjC,UAAU,CAACuC,MAAM,CAAC,CAAC,EAAE;UACzDtD,MAAM,CAACI,GAAG,CAAC,uFAAuFgD,QAAQ,CAACC,eAAe,EAAE,CAAC;UAC7H,IAAI,CAACtC,UAAU,CAACoC,MAAM,CAAC,CAAC;QAC1B;MACF,CAAC,EAAG,GAAG,CAAC;IACV;EACF;AACF;AAEAtC,iBAAiB,CAACY,cAAc,GAAG,CAAC;AAEpCZ,iBAAiB,CAAC2B,uBAAuB,GAAG,GAAG;AAE/C,IAAIe,QAAQ,GAAG;EACbC,aAAa,EAAE;IACbC,OAAO,EAAE,SAAS;IAClBC,UAAU,EAAE,YAAY;IACxBC,IAAI,EAAE,MAAM;IACZC,YAAY,EAAE,sBAAsB;IACpCC,SAAS,EAAE;EACb,CAAC;EACDC,kBAAkB,EAAE;IAClBC,YAAY,EAAE,cAAc;IAC5BC,eAAe,EAAE,iBAAiB;IAClCC,cAAc,EAAE,gBAAgB;IAChCC,MAAM,EAAE;EACV,CAAC;EACDC,kBAAkB,EAAE,QAAQ;EAC5BC,SAAS,EAAE,CAAE,qBAAqB,EAAE,yBAAyB;AAC/D,CAAC;AAED,MAAM;EAACZ,aAAa,EAAEA,aAAa;EAAEY,SAAS,EAAEA;AAAS,CAAC,GAAGb,QAAQ;AAErE,MAAMc,kBAAkB,GAAGD,SAAS,CAACE,KAAK,CAAC,CAAC,EAAEF,SAAS,CAACG,MAAM,GAAG,CAAC,CAAC;AAEnE,MAAMC,OAAO,GAAG,EAAE,CAACA,OAAO;AAE1B,MAAMC,UAAU,CAAC;EACf3D,WAAWA,CAAC4D,QAAQ,EAAE;IACpB,IAAI,CAACC,IAAI,GAAG,IAAI,CAACA,IAAI,CAAC1D,IAAI,CAAC,IAAI,CAAC;IAChC,IAAI,CAACyD,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACE,aAAa,GAAG,IAAI,CAACF,QAAQ,CAACE,aAAa;IAChD,IAAI,CAACC,OAAO,GAAG,IAAIhE,iBAAiB,CAAC,IAAI,CAAC;IAC1C,IAAI,CAACiE,YAAY,GAAG,IAAI;EAC1B;EACAC,IAAIA,CAACC,IAAI,EAAE;IACT,IAAI,IAAI,CAAC1B,MAAM,CAAC,CAAC,EAAE;MACjB,IAAI,CAAC2B,SAAS,CAACF,IAAI,CAACG,IAAI,CAACC,SAAS,CAACH,IAAI,CAAC,CAAC;MACzC,OAAO,IAAI;IACb,CAAC,MAAM;MACL,OAAO,KAAK;IACd;EACF;EACAL,IAAIA,CAAA,EAAG;IACL,IAAI,IAAI,CAACS,QAAQ,CAAC,CAAC,EAAE;MACnBpF,MAAM,CAACI,GAAG,CAAC,uDAAuD,IAAI,CAACiF,QAAQ,CAAC,CAAC,EAAE,CAAC;MACpF,OAAO,KAAK;IACd,CAAC,MAAM;MACL,MAAMC,eAAe,GAAG,CAAE,GAAGlB,SAAS,EAAE,IAAG,IAAI,CAACM,QAAQ,CAACa,YAAY,IAAI,EAAE,EAAE;MAC7EvF,MAAM,CAACI,GAAG,CAAC,uCAAuC,IAAI,CAACiF,QAAQ,CAAC,CAAC,mBAAmBC,eAAe,EAAE,CAAC;MACtG,IAAI,IAAI,CAACL,SAAS,EAAE;QAClB,IAAI,CAACO,sBAAsB,CAAC,CAAC;MAC/B;MACA,IAAI,CAACP,SAAS,GAAG,IAAIlF,QAAQ,CAACI,SAAS,CAAC,IAAI,CAACuE,QAAQ,CAACe,GAAG,EAAEH,eAAe,CAAC;MAC3E,IAAI,CAACI,oBAAoB,CAAC,CAAC;MAC3B,IAAI,CAACb,OAAO,CAAC1D,KAAK,CAAC,CAAC;MACpB,OAAO,IAAI;IACb;EACF;EACAwE,KAAKA,CAAC;IAACC,cAAc,EAAEA;EAAc,CAAC,GAAG;IACvCA,cAAc,EAAE;EAClB,CAAC,EAAE;IACD,IAAI,CAACA,cAAc,EAAE;MACnB,IAAI,CAACf,OAAO,CAACnD,IAAI,CAAC,CAAC;IACrB;IACA,IAAI,IAAI,CAAC4B,MAAM,CAAC,CAAC,EAAE;MACjB,OAAO,IAAI,CAAC2B,SAAS,CAACU,KAAK,CAAC,CAAC;IAC/B;EACF;EACAxC,MAAMA,CAAA,EAAG;IACPnD,MAAM,CAACI,GAAG,CAAC,yCAAyC,IAAI,CAACiF,QAAQ,CAAC,CAAC,EAAE,CAAC;IACtE,IAAI,IAAI,CAACD,QAAQ,CAAC,CAAC,EAAE;MACnB,IAAI;QACF,OAAO,IAAI,CAACO,KAAK,CAAC,CAAC;MACrB,CAAC,CAAC,OAAOE,KAAK,EAAE;QACd7F,MAAM,CAACI,GAAG,CAAC,4BAA4B,EAAEyF,KAAK,CAAC;MACjD,CAAC,SAAS;QACR7F,MAAM,CAACI,GAAG,CAAC,0BAA0B,IAAI,CAACU,WAAW,CAACgF,WAAW,IAAI,CAAC;QACtEzD,UAAU,CAAC,IAAI,CAACsC,IAAI,EAAE,IAAI,CAAC7D,WAAW,CAACgF,WAAW,CAAC;MACrD;IACF,CAAC,MAAM;MACL,OAAO,IAAI,CAACnB,IAAI,CAAC,CAAC;IACpB;EACF;EACAoB,WAAWA,CAAA,EAAG;IACZ,IAAI,IAAI,CAACd,SAAS,EAAE;MAClB,OAAO,IAAI,CAACA,SAAS,CAACe,QAAQ;IAChC;EACF;EACA1C,MAAMA,CAAA,EAAG;IACP,OAAO,IAAI,CAAC2C,OAAO,CAAC,MAAM,CAAC;EAC7B;EACAb,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACa,OAAO,CAAC,MAAM,EAAE,YAAY,CAAC;EAC3C;EACAC,gBAAgBA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACrB,OAAO,CAAC3D,iBAAiB,GAAG,CAAC;EAC3C;EACAiF,mBAAmBA,CAAA,EAAG;IACpB,OAAO3B,OAAO,CAAC4B,IAAI,CAAC/B,kBAAkB,EAAE,IAAI,CAAC0B,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC;EAClE;EACAE,OAAOA,CAAC,GAAGI,MAAM,EAAE;IACjB,OAAO7B,OAAO,CAAC4B,IAAI,CAACC,MAAM,EAAE,IAAI,CAAChB,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC;EACnD;EACAA,QAAQA,CAAA,EAAG;IACT,IAAI,IAAI,CAACJ,SAAS,EAAE;MAClB,KAAK,IAAIqB,KAAK,IAAIvG,QAAQ,CAACI,SAAS,EAAE;QACpC,IAAIJ,QAAQ,CAACI,SAAS,CAACmG,KAAK,CAAC,KAAK,IAAI,CAACrB,SAAS,CAACsB,UAAU,EAAE;UAC3D,OAAOD,KAAK,CAACE,WAAW,CAAC,CAAC;QAC5B;MACF;IACF;IACA,OAAO,IAAI;EACb;EACAd,oBAAoBA,CAAA,EAAG;IACrB,KAAK,IAAIe,SAAS,IAAI,IAAI,CAACC,MAAM,EAAE;MACjC,MAAMC,OAAO,GAAG,IAAI,CAACD,MAAM,CAACD,SAAS,CAAC,CAACxF,IAAI,CAAC,IAAI,CAAC;MACjD,IAAI,CAACgE,SAAS,CAAC,KAAKwB,SAAS,EAAE,CAAC,GAAGE,OAAO;IAC5C;EACF;EACAnB,sBAAsBA,CAAA,EAAG;IACvB,KAAK,IAAIiB,SAAS,IAAI,IAAI,CAACC,MAAM,EAAE;MACjC,IAAI,CAACzB,SAAS,CAAC,KAAKwB,SAAS,EAAE,CAAC,GAAG,YAAW,CAAC,CAAC;IAClD;EACF;AACF;AAEAhC,UAAU,CAACqB,WAAW,GAAG,GAAG;AAE5BrB,UAAU,CAACmC,SAAS,CAACF,MAAM,GAAG;EAC5BG,OAAOA,CAACC,KAAK,EAAE;IACb,IAAI,CAAC,IAAI,CAACX,mBAAmB,CAAC,CAAC,EAAE;MAC/B;IACF;IACA,MAAM;MAACY,UAAU,EAAEA,UAAU;MAAEF,OAAO,EAAEA,OAAO;MAAEG,MAAM,EAAEA,MAAM;MAAEC,SAAS,EAAEA,SAAS;MAAEC,IAAI,EAAEA;IAAI,CAAC,GAAGhC,IAAI,CAACiC,KAAK,CAACL,KAAK,CAAC9B,IAAI,CAAC;IAC3H,IAAI,CAACH,OAAO,CAAChD,aAAa,CAAC,CAAC;IAC5B,QAAQqF,IAAI;MACX,KAAK1D,aAAa,CAACC,OAAO;QACzB,IAAI,IAAI,CAACyC,gBAAgB,CAAC,CAAC,EAAE;UAC3B,IAAI,CAACkB,kBAAkB,GAAG,IAAI;QAChC;QACA,IAAI,CAACvC,OAAO,CAAC9C,aAAa,CAAC,CAAC;QAC5B,OAAO,IAAI,CAAC6C,aAAa,CAACyC,MAAM,CAAC,CAAC;MAEnC,KAAK7D,aAAa,CAACE,UAAU;QAC5B1D,MAAM,CAACI,GAAG,CAAC,0BAA0B4G,MAAM,EAAE,CAAC;QAC9C,OAAO,IAAI,CAACrB,KAAK,CAAC;UAChBC,cAAc,EAAEqB;QAClB,CAAC,CAAC;MAEH,KAAKzD,aAAa,CAACG,IAAI;QACtB,OAAO,IAAI;MAEZ,KAAKH,aAAa,CAACI,YAAY;QAC9B,IAAI,CAACgB,aAAa,CAAC0C,mBAAmB,CAACP,UAAU,CAAC;QAClD,IAAI,IAAI,CAACK,kBAAkB,EAAE;UAC3B,IAAI,CAACA,kBAAkB,GAAG,KAAK;UAC/B,OAAO,IAAI,CAACxC,aAAa,CAAC2C,MAAM,CAACR,UAAU,EAAE,WAAW,EAAE;YACxDS,WAAW,EAAE;UACf,CAAC,CAAC;QACJ,CAAC,MAAM;UACL,OAAO,IAAI,CAAC5C,aAAa,CAAC2C,MAAM,CAACR,UAAU,EAAE,WAAW,EAAE;YACxDS,WAAW,EAAE;UACf,CAAC,CAAC;QACJ;MAED,KAAKhE,aAAa,CAACK,SAAS;QAC3B,OAAO,IAAI,CAACe,aAAa,CAAC6C,MAAM,CAACV,UAAU,CAAC;MAE7C;QACC,OAAO,IAAI,CAACnC,aAAa,CAAC2C,MAAM,CAACR,UAAU,EAAE,UAAU,EAAEF,OAAO,CAAC;IACnE;EACF,CAAC;EACDlC,IAAIA,CAAA,EAAG;IACL3E,MAAM,CAACI,GAAG,CAAC,kCAAkC,IAAI,CAAC2F,WAAW,CAAC,CAAC,eAAe,CAAC;IAC/E,IAAI,CAACjB,YAAY,GAAG,KAAK;IACzB,IAAI,CAAC,IAAI,CAACqB,mBAAmB,CAAC,CAAC,EAAE;MAC/BnG,MAAM,CAACI,GAAG,CAAC,8DAA8D,CAAC;MAC1E,OAAO,IAAI,CAACuF,KAAK,CAAC;QAChBC,cAAc,EAAE;MAClB,CAAC,CAAC;IACJ;EACF,CAAC;EACDD,KAAKA,CAACmB,KAAK,EAAE;IACX9G,MAAM,CAACI,GAAG,CAAC,yBAAyB,CAAC;IACrC,IAAI,IAAI,CAAC0E,YAAY,EAAE;MACrB;IACF;IACA,IAAI,CAACA,YAAY,GAAG,IAAI;IACxB,IAAI,CAACD,OAAO,CAAC5C,gBAAgB,CAAC,CAAC;IAC/B,OAAO,IAAI,CAAC2C,aAAa,CAAC8C,SAAS,CAAC,cAAc,EAAE;MAClDC,oBAAoB,EAAE,IAAI,CAAC9C,OAAO,CAACzD,SAAS,CAAC;IAC/C,CAAC,CAAC;EACJ,CAAC;EACDyE,KAAKA,CAAA,EAAG;IACN7F,MAAM,CAACI,GAAG,CAAC,yBAAyB,CAAC;EACvC;AACF,CAAC;AAED,MAAMwH,MAAM,GAAG,SAAAA,CAASC,MAAM,EAAEC,UAAU,EAAE;EAC1C,IAAIA,UAAU,IAAI,IAAI,EAAE;IACtB,KAAK,IAAIC,GAAG,IAAID,UAAU,EAAE;MAC1B,MAAME,KAAK,GAAGF,UAAU,CAACC,GAAG,CAAC;MAC7BF,MAAM,CAACE,GAAG,CAAC,GAAGC,KAAK;IACrB;EACF;EACA,OAAOH,MAAM;AACf,CAAC;AAED,MAAMI,YAAY,CAAC;EACjBnH,WAAWA,CAAC4D,QAAQ,EAAEwD,MAAM,GAAG,CAAC,CAAC,EAAEC,KAAK,EAAE;IACxC,IAAI,CAACzD,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACqC,UAAU,GAAG7B,IAAI,CAACC,SAAS,CAAC+C,MAAM,CAAC;IACxCN,MAAM,CAAC,IAAI,EAAEO,KAAK,CAAC;EACrB;EACAC,OAAOA,CAACC,MAAM,EAAErD,IAAI,GAAG,CAAC,CAAC,EAAE;IACzBA,IAAI,CAACqD,MAAM,GAAGA,MAAM;IACpB,OAAO,IAAI,CAACtD,IAAI,CAACC,IAAI,CAAC;EACxB;EACAD,IAAIA,CAACC,IAAI,EAAE;IACT,OAAO,IAAI,CAACN,QAAQ,CAACK,IAAI,CAAC;MACxBuD,OAAO,EAAE,SAAS;MAClBvB,UAAU,EAAE,IAAI,CAACA,UAAU;MAC3B/B,IAAI,EAAEE,IAAI,CAACC,SAAS,CAACH,IAAI;IAC3B,CAAC,CAAC;EACJ;EACAuD,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAI,CAAC7D,QAAQ,CAACE,aAAa,CAAC4D,MAAM,CAAC,IAAI,CAAC;EACjD;AACF;AAEA,MAAMC,qBAAqB,CAAC;EAC1B3H,WAAWA,CAAC8D,aAAa,EAAE;IACzB,IAAI,CAACA,aAAa,GAAGA,aAAa;IAClC,IAAI,CAAC8D,oBAAoB,GAAG,EAAE;EAChC;EACAC,SAASA,CAACC,YAAY,EAAE;IACtB,IAAI,IAAI,CAACF,oBAAoB,CAAClE,OAAO,CAACoE,YAAY,CAAC,IAAI,CAAC,CAAC,EAAE;MACzD5I,MAAM,CAACI,GAAG,CAAC,sCAAsCwI,YAAY,CAAC7B,UAAU,EAAE,CAAC;MAC3E,IAAI,CAAC2B,oBAAoB,CAACnI,IAAI,CAACqI,YAAY,CAAC;IAC9C,CAAC,MAAM;MACL5I,MAAM,CAACI,GAAG,CAAC,8CAA8CwI,YAAY,CAAC7B,UAAU,EAAE,CAAC;IACrF;IACA,IAAI,CAAC8B,iBAAiB,CAAC,CAAC;EAC1B;EACAC,MAAMA,CAACF,YAAY,EAAE;IACnB5I,MAAM,CAACI,GAAG,CAAC,oCAAoCwI,YAAY,CAAC7B,UAAU,EAAE,CAAC;IACzE,IAAI,CAAC2B,oBAAoB,GAAG,IAAI,CAACA,oBAAoB,CAACK,MAAM,CAAEC,CAAC,IAAIA,CAAC,KAAKJ,YAAa,CAAC;EACzF;EACAC,iBAAiBA,CAAA,EAAG;IAClB,IAAI,CAACI,gBAAgB,CAAC,CAAC;IACvB,IAAI,CAACC,gBAAgB,CAAC,CAAC;EACzB;EACAD,gBAAgBA,CAAA,EAAG;IACjB9G,YAAY,CAAC,IAAI,CAACgH,YAAY,CAAC;EACjC;EACAD,gBAAgBA,CAAA,EAAG;IACjB,IAAI,CAACC,YAAY,GAAG9G,UAAU,CAAE,MAAM;MACpC,IAAI,IAAI,CAACuC,aAAa,IAAI,OAAO,IAAI,CAACA,aAAa,CAACwE,SAAS,KAAK,UAAU,EAAE;QAC5E,IAAI,CAACV,oBAAoB,CAACW,GAAG,CAAET,YAAY,IAAI;UAC7C5I,MAAM,CAACI,GAAG,CAAC,uCAAuCwI,YAAY,CAAC7B,UAAU,EAAE,CAAC;UAC5E,IAAI,CAACnC,aAAa,CAACwE,SAAS,CAACR,YAAY,CAAC;QAC5C,CAAE,CAAC;MACL;IACF,CAAC,EAAG,GAAG,CAAC;EACV;AACF;AAEA,MAAMU,aAAa,CAAC;EAClBxI,WAAWA,CAAC4D,QAAQ,EAAE;IACpB,IAAI,CAACA,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAAC6E,SAAS,GAAG,IAAId,qBAAqB,CAAC,IAAI,CAAC;IAChD,IAAI,CAAC7D,aAAa,GAAG,EAAE;EACzB;EACA4E,MAAMA,CAACC,WAAW,EAAEtB,KAAK,EAAE;IACzB,MAAMuB,OAAO,GAAGD,WAAW;IAC3B,MAAMvB,MAAM,GAAG,OAAOwB,OAAO,KAAK,QAAQ,GAAGA,OAAO,GAAG;MACrDA,OAAO,EAAEA;IACX,CAAC;IACD,MAAMd,YAAY,GAAG,IAAIX,YAAY,CAAC,IAAI,CAACvD,QAAQ,EAAEwD,MAAM,EAAEC,KAAK,CAAC;IACnE,OAAO,IAAI,CAACwB,GAAG,CAACf,YAAY,CAAC;EAC/B;EACAe,GAAGA,CAACf,YAAY,EAAE;IAChB,IAAI,CAAChE,aAAa,CAACrE,IAAI,CAACqI,YAAY,CAAC;IACrC,IAAI,CAAClE,QAAQ,CAACkF,sBAAsB,CAAC,CAAC;IACtC,IAAI,CAACrC,MAAM,CAACqB,YAAY,EAAE,aAAa,CAAC;IACxC,IAAI,CAACQ,SAAS,CAACR,YAAY,CAAC;IAC5B,OAAOA,YAAY;EACrB;EACAJ,MAAMA,CAACI,YAAY,EAAE;IACnB,IAAI,CAACE,MAAM,CAACF,YAAY,CAAC;IACzB,IAAI,CAAC,IAAI,CAACiB,OAAO,CAACjB,YAAY,CAAC7B,UAAU,CAAC,CAACxC,MAAM,EAAE;MACjD,IAAI,CAACuF,WAAW,CAAClB,YAAY,EAAE,aAAa,CAAC;IAC/C;IACA,OAAOA,YAAY;EACrB;EACAnB,MAAMA,CAACV,UAAU,EAAE;IACjB,OAAO,IAAI,CAAC8C,OAAO,CAAC9C,UAAU,CAAC,CAACsC,GAAG,CAAET,YAAY,IAAI;MACnD,IAAI,CAACE,MAAM,CAACF,YAAY,CAAC;MACzB,IAAI,CAACrB,MAAM,CAACqB,YAAY,EAAE,UAAU,CAAC;MACrC,OAAOA,YAAY;IACrB,CAAE,CAAC;EACL;EACAE,MAAMA,CAACF,YAAY,EAAE;IACnB,IAAI,CAACW,SAAS,CAACT,MAAM,CAACF,YAAY,CAAC;IACnC,IAAI,CAAChE,aAAa,GAAG,IAAI,CAACA,aAAa,CAACmE,MAAM,CAAEC,CAAC,IAAIA,CAAC,KAAKJ,YAAa,CAAC;IACzE,OAAOA,YAAY;EACrB;EACAiB,OAAOA,CAAC9C,UAAU,EAAE;IAClB,OAAO,IAAI,CAACnC,aAAa,CAACmE,MAAM,CAAEC,CAAC,IAAIA,CAAC,CAACjC,UAAU,KAAKA,UAAW,CAAC;EACtE;EACAM,MAAMA,CAAA,EAAG;IACP,OAAO,IAAI,CAACzC,aAAa,CAACyE,GAAG,CAAET,YAAY,IAAI,IAAI,CAACQ,SAAS,CAACR,YAAY,CAAE,CAAC;EAC/E;EACAlB,SAASA,CAACqC,YAAY,EAAE,GAAGC,IAAI,EAAE;IAC/B,OAAO,IAAI,CAACpF,aAAa,CAACyE,GAAG,CAAET,YAAY,IAAI,IAAI,CAACrB,MAAM,CAACqB,YAAY,EAAEmB,YAAY,EAAE,GAAGC,IAAI,CAAE,CAAC;EACnG;EACAzC,MAAMA,CAACqB,YAAY,EAAEmB,YAAY,EAAE,GAAGC,IAAI,EAAE;IAC1C,IAAIpF,aAAa;IACjB,IAAI,OAAOgE,YAAY,KAAK,QAAQ,EAAE;MACpChE,aAAa,GAAG,IAAI,CAACiF,OAAO,CAACjB,YAAY,CAAC;IAC5C,CAAC,MAAM;MACLhE,aAAa,GAAG,CAAEgE,YAAY,CAAE;IAClC;IACA,OAAOhE,aAAa,CAACyE,GAAG,CAAET,YAAY,IAAI,OAAOA,YAAY,CAACmB,YAAY,CAAC,KAAK,UAAU,GAAGnB,YAAY,CAACmB,YAAY,CAAC,CAAC,GAAGC,IAAI,CAAC,GAAG9J,SAAU,CAAC;EAChJ;EACAkJ,SAASA,CAACR,YAAY,EAAE;IACtB,IAAI,IAAI,CAACkB,WAAW,CAAClB,YAAY,EAAE,WAAW,CAAC,EAAE;MAC/C,IAAI,CAACW,SAAS,CAACZ,SAAS,CAACC,YAAY,CAAC;IACxC;EACF;EACAtB,mBAAmBA,CAACP,UAAU,EAAE;IAC9B/G,MAAM,CAACI,GAAG,CAAC,0BAA0B2G,UAAU,EAAE,CAAC;IAClD,IAAI,CAAC8C,OAAO,CAAC9C,UAAU,CAAC,CAACsC,GAAG,CAAET,YAAY,IAAI,IAAI,CAACW,SAAS,CAACT,MAAM,CAACF,YAAY,CAAE,CAAC;EACrF;EACAkB,WAAWA,CAAClB,YAAY,EAAEN,OAAO,EAAE;IACjC,MAAM;MAACvB,UAAU,EAAEA;IAAU,CAAC,GAAG6B,YAAY;IAC7C,OAAO,IAAI,CAAClE,QAAQ,CAACK,IAAI,CAAC;MACxBuD,OAAO,EAAEA,OAAO;MAChBvB,UAAU,EAAEA;IACd,CAAC,CAAC;EACJ;AACF;AAEA,MAAMkD,QAAQ,CAAC;EACbnJ,WAAWA,CAAC2E,GAAG,EAAE;IACf,IAAI,CAACyE,IAAI,GAAGzE,GAAG;IACf,IAAI,CAACb,aAAa,GAAG,IAAI0E,aAAa,CAAC,IAAI,CAAC;IAC5C,IAAI,CAACvI,UAAU,GAAG,IAAI0D,UAAU,CAAC,IAAI,CAAC;IACtC,IAAI,CAACc,YAAY,GAAG,EAAE;EACxB;EACA,IAAIE,GAAGA,CAAA,EAAG;IACR,OAAO0E,kBAAkB,CAAC,IAAI,CAACD,IAAI,CAAC;EACtC;EACAnF,IAAIA,CAACC,IAAI,EAAE;IACT,OAAO,IAAI,CAACjE,UAAU,CAACgE,IAAI,CAACC,IAAI,CAAC;EACnC;EACAoF,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACrJ,UAAU,CAAC4D,IAAI,CAAC,CAAC;EAC/B;EACAjB,UAAUA,CAAA,EAAG;IACX,OAAO,IAAI,CAAC3C,UAAU,CAAC4E,KAAK,CAAC;MAC3BC,cAAc,EAAE;IAClB,CAAC,CAAC;EACJ;EACAgE,sBAAsBA,CAAA,EAAG;IACvB,IAAI,CAAC,IAAI,CAAC7I,UAAU,CAACqE,QAAQ,CAAC,CAAC,EAAE;MAC/B,OAAO,IAAI,CAACrE,UAAU,CAAC4D,IAAI,CAAC,CAAC;IAC/B;EACF;EACA0F,cAAcA,CAACC,WAAW,EAAE;IAC1B,IAAI,CAAC/E,YAAY,GAAG,CAAE,GAAG,IAAI,CAACA,YAAY,EAAE+E,WAAW,CAAE;EAC3D;AACF;AAEA,SAASH,kBAAkBA,CAAC1E,GAAG,EAAE;EAC/B,IAAI,OAAOA,GAAG,KAAK,UAAU,EAAE;IAC7BA,GAAG,GAAGA,GAAG,CAAC,CAAC;EACb;EACA,IAAIA,GAAG,IAAI,CAAC,SAAS,CAAC8E,IAAI,CAAC9E,GAAG,CAAC,EAAE;IAC/B,MAAM+E,CAAC,GAAGpH,QAAQ,CAACqH,aAAa,CAAC,GAAG,CAAC;IACrCD,CAAC,CAACE,IAAI,GAAGjF,GAAG;IACZ+E,CAAC,CAACE,IAAI,GAAGF,CAAC,CAACE,IAAI;IACfF,CAAC,CAACxE,QAAQ,GAAGwE,CAAC,CAACxE,QAAQ,CAAC2E,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC;IAC7C,OAAOH,CAAC,CAACE,IAAI;EACf,CAAC,MAAM;IACL,OAAOjF,GAAG;EACZ;AACF;AAEA,SAASmF,cAAcA,CAACnF,GAAG,GAAGoF,SAAS,CAAC,KAAK,CAAC,IAAItH,QAAQ,CAACY,kBAAkB,EAAE;EAC7E,OAAO,IAAI8F,QAAQ,CAACxE,GAAG,CAAC;AAC1B;AAEA,SAASoF,SAASA,CAACC,IAAI,EAAE;EACvB,MAAMC,OAAO,GAAG3H,QAAQ,CAAC4H,IAAI,CAACC,aAAa,CAAC,2BAA2BH,IAAI,IAAI,CAAC;EAChF,IAAIC,OAAO,EAAE;IACX,OAAOA,OAAO,CAACG,YAAY,CAAC,SAAS,CAAC;EACxC;AACF;AAEA,SAASzG,UAAU,EAAE5D,iBAAiB,EAAEoJ,QAAQ,EAAE1G,QAAQ,EAAE0E,YAAY,EAAEQ,qBAAqB,EAAEa,aAAa,EAAEvJ,QAAQ,EAAE6K,cAAc,EAAET,kBAAkB,EAAEU,SAAS,EAAE7K,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}